#include "./Helpers/TriangulationHelper.hlsl"

#pragma kernel MarchingCubes

struct ResultTriangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
};

AppendStructuredBuffer<ResultTriangle> resultTriangles;
RWStructuredBuffer<uint> resultTriangleCount;

float distanceBetweenPoints;
float3 chunkOrigin;
float terrainRatio;

int2 midpointPairs[] = {
    {0, 1},
    {1, 2},
    {2, 3},
    {3, 0},
    {4, 5},
    {5, 6},
    {6, 7},
    {7, 4},
    {4, 0},
    {5, 1},
    {6, 2},
    {7, 3}
};

[numthreads(8,8,8)]
void MarchingCubes (uint3 id : SV_DispatchThreadID) {
	float3 cubePositions[] = {
        {chunkOrigin.x + id.x *       distanceBetweenPoints, chunkOrigin.y + id.y       * distanceBetweenPoints, chunkOrigin.z + id.z       * distanceBetweenPoints},
        {chunkOrigin.x + (id.x + 1) * distanceBetweenPoints, chunkOrigin.y + id.y       * distanceBetweenPoints, chunkOrigin.z + id.z       * distanceBetweenPoints},
        {chunkOrigin.x + (id.x + 1) * distanceBetweenPoints, chunkOrigin.y + id.y       * distanceBetweenPoints, chunkOrigin.z + (id.z + 1) * distanceBetweenPoints},
        {chunkOrigin.x + id.x *       distanceBetweenPoints, chunkOrigin.y + id.y       * distanceBetweenPoints, chunkOrigin.z + (id.z + 1) * distanceBetweenPoints},
        {chunkOrigin.x + id.x *       distanceBetweenPoints, chunkOrigin.y + (id.y + 1) * distanceBetweenPoints, chunkOrigin.z + id.z       * distanceBetweenPoints},
        {chunkOrigin.x + (id.x + 1) * distanceBetweenPoints, chunkOrigin.y + (id.y + 1) * distanceBetweenPoints, chunkOrigin.z + id.z       * distanceBetweenPoints},
        {chunkOrigin.x + (id.x + 1) * distanceBetweenPoints, chunkOrigin.y + (id.y + 1) * distanceBetweenPoints, chunkOrigin.z + (id.z + 1) * distanceBetweenPoints},
        {chunkOrigin.x + id.x *       distanceBetweenPoints, chunkOrigin.y + (id.y + 1) * distanceBetweenPoints, chunkOrigin.z + (id.z + 1) * distanceBetweenPoints}
    };

    int cubeValues[8];

    int index = 0;

    for (int i = 0; i < 8; i++) {
        cubeValues[i] = i<4;
        index = index + (cubeValues[i] > 0) * pow(2, i);;
    }

    int midpointVertexIndexes[16] = triTable[index];

    int midpointVertexCount = 0;
    while (midpointVertexIndexes[midpointVertexCount] != -1) {
        midpointVertexCount++;
    }

    for (int i = 0; i < midpointVertexCount/3; i++) {
        ResultTriangle resultTriangle;
        float3 midpoint;

        midpoint = (cubePositions[midpointPairs[midpointVertexIndexes[i * 3]].x]     + cubePositions[midpointPairs[midpointVertexIndexes[i * 3]].y])    / 2;
        resultTriangle.vertexA.x = midpoint.x;
        resultTriangle.vertexA.y = midpoint.y;
        resultTriangle.vertexA.z = midpoint.z;

        midpoint = (cubePositions[midpointPairs[midpointVertexIndexes[i * 3 + 1]].x] + cubePositions[midpointPairs[midpointVertexIndexes[i * 3 + 1]].y]) / 2;
        resultTriangle.vertexB.x = midpoint.x;
        resultTriangle.vertexB.y = midpoint.y;
        resultTriangle.vertexB.z = midpoint.z;

        midpoint = (cubePositions[midpointPairs[midpointVertexIndexes[i * 3 + 2]].x] + cubePositions[midpointPairs[midpointVertexIndexes[i * 3 + 2]].y]) / 2;
        resultTriangle.vertexC.x = midpoint.x;
        resultTriangle.vertexC.y = midpoint.y;
        resultTriangle.vertexC.z = midpoint.z;

        resultTriangles.Append(resultTriangle);
        resultTriangleCount[0]++;
    }
}