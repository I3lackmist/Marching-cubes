#pragma kernel MarchingCubes

#include "./Helpers/TriangulationHelper.hlsl"
#include "./Helpers/ComputeConstants.hlsl"

struct ResultTriangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
};

AppendStructuredBuffer<ResultTriangle> resultTriangles;
StructuredBuffer<int> isoValues;

float distanceBetweenPoints;
float3 chunkOrigin;
int3 chunkIndex;
int isoLevel;

[numthreads(NUM_THREADS, NUM_THREADS, NUM_THREADS)]
void MarchingCubes (uint3 tid : SV_GroupThreadID) {
    if (tid.x >= NUM_THREADS || tid.y >= NUM_THREADS || tid.z >= NUM_THREADS) return;

    float middleOffset = NUM_THREADS * -0.25 * distanceBetweenPoints;

	float3 cubePositions[] = {
        {(tid.x)     * distanceBetweenPoints + middleOffset, (tid.y)     * distanceBetweenPoints + middleOffset, (tid.z)     * distanceBetweenPoints + middleOffset},
        {(tid.x + 1) * distanceBetweenPoints + middleOffset, (tid.y)     * distanceBetweenPoints + middleOffset, (tid.z)     * distanceBetweenPoints + middleOffset},
        {(tid.x + 1) * distanceBetweenPoints + middleOffset, (tid.y)     * distanceBetweenPoints + middleOffset, (tid.z + 1) * distanceBetweenPoints + middleOffset},
        {(tid.x)     * distanceBetweenPoints + middleOffset, (tid.y)     * distanceBetweenPoints + middleOffset, (tid.z + 1) * distanceBetweenPoints + middleOffset},
        {(tid.x)     * distanceBetweenPoints + middleOffset, (tid.y + 1) * distanceBetweenPoints + middleOffset, (tid.z)     * distanceBetweenPoints + middleOffset},
        {(tid.x + 1) * distanceBetweenPoints + middleOffset, (tid.y + 1) * distanceBetweenPoints + middleOffset, (tid.z)     * distanceBetweenPoints + middleOffset},
        {(tid.x + 1) * distanceBetweenPoints + middleOffset, (tid.y + 1) * distanceBetweenPoints + middleOffset, (tid.z + 1) * distanceBetweenPoints + middleOffset},
        {(tid.x)     * distanceBetweenPoints + middleOffset, (tid.y + 1) * distanceBetweenPoints + middleOffset, (tid.z + 1) * distanceBetweenPoints + middleOffset}
    };

    uint index = 0;

    for (uint i = 0; i < 8; i++) {
        index += pow(2,i) * (isoValues[tid.x * 64 + tid.y * 8 + tid.z] > isoLevel);
    }

    uint midpointVertexCount = 0;
    while (TRI_TABLE[index][midpointVertexCount] != -1) {
        midpointVertexCount++;
    }

    for (uint j = 0; j < midpointVertexCount/3; j++) {
        ResultTriangle resultTriangle;

        float3 midpointA;
        float3 midpointB;
        float3 midpointC;

        resultTriangle.vertexA = (cubePositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3]].x]     + cubePositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3]].y])     / 2;
        resultTriangle.vertexB = (cubePositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 1]].x] + cubePositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 1]].y]) / 2;
        resultTriangle.vertexC = (cubePositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 2]].x] + cubePositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 2]].y]) / 2;

        resultTriangles.Append(resultTriangle);
    }
}