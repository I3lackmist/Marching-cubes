#include "./Helpers/TriangulationHelper.hlsl"

#pragma kernel MarchingCubes

static const uint numThreads = 8;

struct ResultTriangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
};

AppendStructuredBuffer<ResultTriangle> resultTriangles;

float distanceBetweenPoints;
float3 chunkOrigin;

[numthreads(numThreads, numThreads, numThreads)]
void MarchingCubes (uint3 tid : SV_GroupThreadID) {
    if (tid.x >= numThreads || tid.y >= numThreads || tid.z >= numThreads) { return; }

	float3 cubePositions[] = {
        {chunkOrigin.x + (float)(tid.x)     * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y)     * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z)     * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x + 1) * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y)     * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z)     * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x + 1) * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y)     * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z + 1) * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x)     * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y)     * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z + 1) * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x)     * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y + 1) * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z)     * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x + 1) * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y + 1) * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z)     * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x + 1) * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y + 1) * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z + 1) * distanceBetweenPoints},
        {chunkOrigin.x + (float)(tid.x)     * distanceBetweenPoints, chunkOrigin.y + (float)(tid.y + 1) * distanceBetweenPoints, chunkOrigin.z + (float)(tid.z + 1) * distanceBetweenPoints}
    };

    int index = 1;

    // int index = 0;
    // for (int i = 0; i < 8; i++) {
    //     index += pow(2,i) * (i>4);
    // }

    int midpointVertexCount = 0;
    while (triTable[index][midpointVertexCount] != -1) {
        midpointVertexCount++;
    }

    for (int j = 0; j < midpointVertexCount/3; j++) {
        ResultTriangle resultTriangle;
        float3 midpointA;
        float3 midpointB;
        float3 midpointC;

        resultTriangle.vertexA = (cubePositions[midpointPairs[triTable[index][j * 3]].x]     + cubePositions[midpointPairs[triTable[index][j * 3]].y])     / 2;
        resultTriangle.vertexB = (cubePositions[midpointPairs[triTable[index][j * 3 + 1]].x] + cubePositions[midpointPairs[triTable[index][j * 3 + 1]].y]) / 2;
        resultTriangle.vertexC = (cubePositions[midpointPairs[triTable[index][j * 3 + 2]].x] + cubePositions[midpointPairs[triTable[index][j * 3 + 2]].y]) / 2;

        resultTriangles.Append(resultTriangle);
    }
}