#include "./FastNoise.hlsl"

#pragma kernel OverworldCutoff 

RWStructuredBuffer<float> noiseValues;
float3 chunkIndex;

int noiseType;
int seed;
float size;

int octaves;
float scale;
float lacunarity;
float persistence;
float maxValue;

float minHeight;
float maxHeight;

float constant;

// just do a heightmap up above
// then do a mask type thing
// in a small height between over and underground, preserve +1 if area is above ground or 0 if under


[numthreads(8, 8, 8)]
void OverworldCutoff(int3 tid : SV_DISPATCHTHREADID)
{
	float posY = (float)tid.y + chunkIndex.y * (size-1);

	if (posY < minHeight) return;

	int index = tid.x + tid.y * 8 + tid.z * 64;
	float noiseVal = noiseValues[index] + constant;

    if (posY > maxHeight) 
    {
        float unitsAwayFromMax = posY - maxHeight;
        noiseValues[index] = noiseVal + unitsAwayFromMax * 0.2;

        return;
    }

	fnl_state noise = fnlCreateState(seed);
	noise.noise_type = noiseType;


	float heightVal = 0;

	float frequency = 1;
	float amplitude = 1;

	float posX = (float)tid.x + chunkIndex.x * (size-1);
	float posZ = (float)tid.z + chunkIndex.z * (size-1);

	float sampleX;
	float sampleZ;

	float randomOffset = 0;

	for (int i = 0; i < octaves; i++) {
		sampleX = posX / scale * frequency;
		sampleZ = posZ / scale * frequency;

		heightVal = heightVal + ((fnlGetNoise2D(noise, sampleX, sampleZ) + 1) * 0.5) * amplitude;

		randomOffset = randomOffset + ((fnlGetNoise2D(noise, sampleX, sampleZ) + 1) * 0.5) * amplitude;
		
		frequency = frequency * lacunarity;
		amplitude = amplitude * persistence;
	}

	heightVal = heightVal / maxValue + constant;
	
	if (posY < heightVal + minHeight) {
		float unitsAway = (heightVal + minHeight) - posY;
		noiseValues[tid.x + tid.y * 8 + tid.z * 64] = noiseVal - unitsAway * 0.2;
		// noiseValues[tid.x + tid.y * 8 + tid.z * 64] = 0;
    }
}
