#include "./TriangulationHelper.hlsl"

#pragma kernel MarchingCubes

struct ResultTriangle {
    float3 vertexA;
    float3 vertexB;
    float3 vertexC;
};

AppendStructuredBuffer<ResultTriangle> resultTriangles;
RWStructuredBuffer<float> noiseValues;

float distanceBetweenPoints;
float isoLevel;

[numthreads(8, 8, 8)]
void MarchingCubes (int3 gtid : SV_DISPATCHTHREADID) {
	if (gtid.x >= 7 || gtid.y >= 7 || gtid.z >= 7) return;

	float3 cornerPositions[] = {
        {(gtid.x)     * distanceBetweenPoints, (gtid.y)     * distanceBetweenPoints, (gtid.z)     * distanceBetweenPoints},
        {(gtid.x + 1) * distanceBetweenPoints, (gtid.y)     * distanceBetweenPoints, (gtid.z)     * distanceBetweenPoints},
        {(gtid.x + 1) * distanceBetweenPoints, (gtid.y)     * distanceBetweenPoints, (gtid.z + 1) * distanceBetweenPoints},
        {(gtid.x)     * distanceBetweenPoints, (gtid.y)     * distanceBetweenPoints, (gtid.z + 1) * distanceBetweenPoints},
        {(gtid.x)     * distanceBetweenPoints, (gtid.y + 1) * distanceBetweenPoints, (gtid.z)     * distanceBetweenPoints},
        {(gtid.x + 1) * distanceBetweenPoints, (gtid.y + 1) * distanceBetweenPoints, (gtid.z)     * distanceBetweenPoints},
        {(gtid.x + 1) * distanceBetweenPoints, (gtid.y + 1) * distanceBetweenPoints, (gtid.z + 1) * distanceBetweenPoints},
        {(gtid.x)     * distanceBetweenPoints, (gtid.y + 1) * distanceBetweenPoints, (gtid.z + 1) * distanceBetweenPoints}
    };

	float cornerValues[] = {
		noiseValues[(gtid.x)     + (gtid.y)     * 8 + (gtid.z)     * 64],
		noiseValues[(gtid.x + 1) + (gtid.y)     * 8 + (gtid.z)     * 64],
		noiseValues[(gtid.x + 1) + (gtid.y)     * 8 + (gtid.z + 1) * 64],
		noiseValues[(gtid.x)     + (gtid.y)     * 8 + (gtid.z + 1) * 64],
		noiseValues[(gtid.x)     + (gtid.y + 1) * 8 + (gtid.z)     * 64],
		noiseValues[(gtid.x + 1) + (gtid.y + 1) * 8 + (gtid.z)     * 64],
		noiseValues[(gtid.x + 1) + (gtid.y + 1) * 8 + (gtid.z + 1) * 64],
		noiseValues[(gtid.x)     + (gtid.y + 1) * 8 + (gtid.z + 1) * 64]
	};

    int index = 0;
    for (int i = 0; i < 8; i++) {
		if (cornerValues[i] < isoLevel) index += pow(2, i);
    }

    int midpointVertexCount = 0;

    while (TRI_TABLE[index][midpointVertexCount] != -1) {
        midpointVertexCount++;
    }

	int triCount = 0;

    for (int j = 0; j < midpointVertexCount/3; j++) {
        ResultTriangle resultTriangle;

        float3 midpointA;
        float3 midpointB;
        float3 midpointC;

        resultTriangle.vertexA = (cornerPositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3]].x]     + cornerPositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3]].y])     / 2;
        resultTriangle.vertexB = (cornerPositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 1]].x] + cornerPositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 1]].y]) / 2;
        resultTriangle.vertexC = (cornerPositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 2]].x] + cornerPositions[MIDPOINT_PAIRS[TRI_TABLE[index][j * 3 + 2]].y]) / 2;

        resultTriangles.Append(resultTriangle);
    }
}